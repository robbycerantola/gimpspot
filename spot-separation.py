#!/usr/bin/env python
# This is a Gimp plug-in for making spot color separation (suitable for screen printing)
# starting from a photo in sRGB format.
# It will reduce first the numbers of the colors accordingly to the custom palette prepared by the user.
# The color palette has to have 
# all the colours you think 
# you need to make a good approximation of the original photo/artwork.
#
# spot-separation.py V0.2.4   Copyright Robby Cerantola  2010-2011  robbycerantola@gmail.com

# The program is distributed under the terms of the GNU General Public License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Maximum number of colours = 14 
# OPTIONS description:
#
# Marks & Bars: put registration marks, color squares to better identify every colour  on the bottom of the separated
# layers plus some text information about filename, colour name (accordingly with names stored in the current palette),
# resolution pixel enlargement factor
# Multiple files : save in the current directory as many black&white files as the colors in the final image,
# useful to be imported in RIP software for printing or CorelDraw(TM);if not selected it will be saved only one multilayer
# PSD file.  

# Pixel enlargement factor: reduces resolution but not final printing dimension in mm  to get a bigger dot, 
# useful to get a better silkscreen. Usually a 2 factor is enough, bigger factor come with a bigger loose of details, 
# important is also the starting resolution of the original image. 
#
# Automatic underlayer: (fondino) Makes an extra under-layer for all the separated layers for screen printing a white base to be over printed. 
# Automated background deletion from final layers (Count pixels by histogram and delete the layer with bigger pixel counter)

#Done: 02-11-2010 shrink under-layer (fondino has to be a little smaller than the upper layers to be not visible at all!)
#TODO Automate palette creation
#TODO Alternative method using channels  (partially implemented)
#TODO Clean up and speed up the code
#Done: 07-11-2010 undo is functional but uses a lot of memory! (Is there a better way?)
#TODO preview

#Done: 01-11-2010 Corrected "block"bug and Cross-hair for pixel enlargement >1  
#Done: 09-11-2010 Corrected bug: Image was distorted if a drawable had other dimensions than image dimensions and was selected
#                                just before doing spot-separation. 
#                 multiple files saves now EPS files because RIP does not print correctly tiff images generated by Gimp !!


import math
from gimpfu import *
import os


debug=1        #output some debug information on console
maxnumcol=14   #max number of final colours
maxenlarge=5   #max pixel enlargement factor
shrink=1       #nr of pixels for shrinking/growing underlayer

dithermode=["None","Floyd-Steinberg","Floyd-Steinberg _reduced","Fixed"]

def export_layers(img, drw, path, flatten=False,nname=""):
    """Exports layers into separate monochrome tif files identified by colour name"""
    dupe = img.duplicate()
    for layer in dupe.layers:
        layer.visible = 0
    for layer in dupe.layers:
        layer.visible = 1
        name = nname+"_"+layer.name + ".eps"
        fullpath = os.path.join(path, name);
        tmp = dupe.duplicate()
        if (flatten):  #in CorelDraw we need it Black/white to be coloured afterwards
            tmp.flatten()
            ##pdb.gimp_image_convert_rgb(tmp)
            pdb.gimp_convert_indexed(tmp,0,3,2,0,0,"fake")
        pdb.gimp_file_save(tmp, tmp.layers[0], fullpath, name)
        dupe.remove_layer(layer)

def export_channels(img, drw, path, flatten=False,nname=""):
    """Exports channels into separate monochrome png files identified by colour name"""
	# original routine from  
	# Author: Chris Mohler
    # Copyright 2010 Chris Mohler
    # modified by Robby Cerantola for saving EPS
    dupe = img.duplicate()
    for layer in dupe.layers:
        layer.visible = 0
        for channel in dupe.channels:
                channel.visible = 0
    for channel in dupe.channels:
        channel.visible = 1
        name = nname+"_"+channel.name + ".eps"
        fullpath = os.path.join(path, name);
        tmp = dupe.duplicate()
        #pdb.file_png_save(tmp, tmp.channels[0], fullpath, name, 0, 9, 1, 1, 1, 1, 1)
        pdb.gimp_file_save(tmp, tmp.channels[0], fullpath, name)
        dupe.remove_channel(channel)
    

def spot_palette(timg,tdrawable,mode=0,option=False):
    """Prepare palette for spot separation"""
    palette=timg.name
    palette,ext=os.path.splitext(palette)
    palette=pdb.gimp_palette_new(palette)
    if debug:print"Created new palette:%s" % palette
    #pdb.gimp_palette_add_entry(palette,"black",(0,0,0))
    #pdb.gimp_palette_add_entry(palette,"white",(255,255,255))
    timg.flatten() # flatten the image so you can easily pick up the colours from image
    pdb.gimp_message("New %s empty palette created. You have to fill it manually with the color picker tool !"% palette)
    #pdb.gimp_palettes_popup("palette_callback","Choose_next_colours",palette)
    
def compute(img,drawable,kind=0):
    """Tries to guess a suitable pixel enlargement factor"""
    odd=[0.01,0.015,0.008,0.005] # optimal printing dot dimension in inches for generic,waterbased,plastisol,transfer based on personal experience
    
    x=img.width
    y=img.height
    xres,yres=pdb.gimp_image_get_resolution(img)
    cdd=1.0/xres
    pef=int(odd[kind]/cdd)
    if pef<1 :pef=1
    message="Image is %sx%s pixels \nresolution is %sx%s ppi\ncurrent pixel dimension=%sinches \nsuggested pixel enlargement factor is %s " % (x,y,xres,yres,cdd,pef)
    if xres <100 : message=message+"\n \n Attention:resolution image seems to bee too poor for screen printing!!"
    pdb.gimp_message(message)
    return pef



def palette_callback(img,drawable):
    return

def background_deletion(timg):
    if debug:print"Deleting background"
    gimp.progress_init("Deleting background...")
    gimp.progress_update(0.5)
    biggerlayer=None
    oldpixelcount=0
    for curent_layer in timg.layers:
        timg.active_layer=curent_layer
        
        #set layer pixel counter for current layer (color) needed for background deletion
        (a,b,c,pixelcount,e,f)=pdb.gimp_histogram(timg.active_layer,0,0,255) 
        if pixelcount>oldpixelcount:
            oldpixelcount=pixelcount
            biggerlayer=curent_layer

    #delete found background
    timg.remove_layer(biggerlayer)
    gimp.progress_update(1)


def create_underlayer(img,underlayer,value=1,enlargement=1,marks=0):
    if debug:print "Underlayer drawable",img.layers[0]
    gimp.progress_init("Creating underlayer")
    gimp.progress_update(0.5)
    
    dupe=img.duplicate()
    undl=pdb.gimp_image_merge_visible_layers(dupe,1)
    

    ## Added for correcting underlayer issues
    #we select the block zone and delete it!
    pdb.gimp_rect_select(dupe,0,dupe.height-130,dupe.width,dupe.height,0,False,0)
    #delete selection
    pdb.gimp_edit_clear(undl)
    #select all
    pdb.gimp_selection_all(dupe)
    ## end
    
    pdb.gimp_edit_copy(undl)
    floating=pdb.gimp_edit_paste(img.layers[0],0)
    pdb.gimp_edit_fill(floating,0)
    pdb.gimp_layer_resize_to_image_size(floating)
    pdb.gimp_floating_sel_to_layer(floating)
    pdb.gimp_image_delete(dupe)
    pdb.gimp_drawable_set_name(floating,"Underlayer")
    if underlayer == 2:
        #Enlarge underlayer
        pdb.gimp_selection_layer_alpha(floating)
        pdb.gimp_selection_grow(img,value)
        pdb.gimp_edit_fill(floating,0)
    if underlayer == 3:
        #Shrink underlayer   
        pdb.gimp_selection_layer_alpha(floating)
        pdb.gimp_edit_clear(floating)
        pdb.gimp_selection_shrink(img,value)
        pdb.gimp_edit_fill(floating,0)
    
    
    
    pdb.gimp_selection_none(img)    
    
    ##end
    
    gimp.progress_update(1)
    
def spot_separation(timg, tdrawable, palette="Default", dither=2,transparency=False,marks=False, multiple=False,delback=False,underlayer=0,enlargement=1,chla=0,wdir=os.getcwd() ):
    """ spot color separation """
    
    if pdb.gimp_drawable_is_indexed(tdrawable)== True:  #it has to be a RGB image!!
        return 
    
    pdb.gimp_image_undo_group_start(timg)
    
    width = timg.width          #get all image width / height
    height = timg.height
    nrcol=pdb.gimp_palette_get_info(palette)
    pixelcount=[]
    nwdrawable=timg.flatten() # flatten all existing layers first !! (this solve also block bug)
    if enlargement>maxenlarge :
        enlargement=maxenlarge
    if enlargement>1:    #makes a "bigger" pixel
        xres,yres=pdb.gimp_image_get_resolution(timg)
        width=int(width/enlargement)
        height=int(height/enlargement)
        pdb.gimp_image_set_resolution(timg,int(xres/enlargement),int(yres/enlargement))
        nwdrawable=pdb.gimp_drawable_transform_scale(nwdrawable,0,0,width,height,0,0,0,3,0)
    
	#making room for palette and marks  
    
    pdb.gimp_context_set_background(pdb.gimp_palette_entry_get_color(palette,2)) # background is the first color in the palette
    
    pdb.gimp_image_resize(timg,width,height+130,0,0)
    
    pdb.gimp_layer_resize(nwdrawable,width,height+130,0,0)
    
    original_active = timg.active_layer
        
    bartext="Selection of %s colours..." %nrcol
    pdb.gimp_progress_set_text(bartext)	
    
    numlayers,layerids=pdb.gimp_image_get_layers(timg)
    masterlayer=layerids[numlayers-1]
    
    if debug:print "Layer ID is ",masterlayer,layerids    

    if nrcol < maxnumcol: 	
        gimp.progress_init("Separating...")
        
        
        
            
        pdb.gimp_convert_indexed(timg,dither,4,nrcol,0,0,palette)		
        pdb.gimp_image_convert_rgb(timg) #convert back to rgb so black and white colours has not to be present on custom palette!!
        
        pdb.gimp_context_set_brush("BigSquare")
        
        #draw some squares coloured in palette colours
        if marks==True:
            
            xpos=100
            ypos=height+50
            delta=int((width-200)/nrcol)
            if delta > 100:
                delta=100
            for idxcol in range(1,nrcol):
                xpos=xpos+delta
                color=pdb.gimp_palette_entry_get_color(palette,idxcol)	
                if debug:print"Drawing coloured block ",color
                pdb.gimp_context_set_foreground(color)	
            
                pdb.gimp_paintbrush(nwdrawable,0,2,[xpos,ypos,xpos,ypos],0,0)
        
        ##pdb.gimp_convert_indexed(timg,dither,4,nrcol,0,0,palette)	                
            
            
                
        pdb.gimp_context_set_foreground(pdb.gimp_palette_entry_get_color(palette,0)) # set black foreground mo make selection black
        
        pdb.gimp_context_set_background(pdb.gimp_palette_entry_get_color(palette,1))# set white background 
        
        
        for idxcol in range(0,nrcol):		
            
            fraction=idxcol*(1.0/nrcol)
            gimp.progress_update(fraction)
            
            timg.active_layer = original_active
            color=pdb.gimp_palette_entry_get_color(palette,idxcol)
                     
            pdb.gimp_by_color_select(nwdrawable,color,0,0,0,0,0,0)           
            
            
            
            
            if chla==1: #create channels instead of layers (experimental)
                if debug:print "Creating new Channel"
                pdb.gimp_selection_invert(timg)
                ch=pdb.gimp_selection_save(timg)
                pdb.gimp_channel_set_opacity(ch,100)
                pdb.gimp_drawable_set_name(ch,pdb.gimp_palette_entry_get_name(palette,idxcol))
                pdb.gimp_selection_none(timg)
                
            else:    # create layers instead of channels
                pdb.gimp_edit_copy(nwdrawable)    #copy&paste way 1/2
                floating=pdb.gimp_edit_paste(nwdrawable,0)       #2/2      
                if multiple==True:
                    pdb.gimp_context_set_foreground(pdb.gimp_palette_entry_get_color("Default",12))                 
                    pdb.gimp_edit_fill(floating,0)  #fill the current selection with black 
                pdb.gimp_layer_resize_to_image_size(floating) # resize curent layer to the image size
                #floating=pdb.gimp_selection_float(nwdrawable,0,0)       #alternative way 1/1    
                pdb.gimp_floating_sel_to_layer(floating)
            
                #set layer name accordingly the palette colour name (or index)
                layernewname=pdb.gimp_palette_entry_get_name(palette,idxcol)
                if layernewname =="Immagine" or layernewname=="Untitled" :
                    layernewname="Col #"+str(idxcol)
                floating.name=layernewname      
                       
           
        
        
        if chla==1: # elaborate as channels 
            #TODO open channels docker
            name,ext =os.path.splitext(timg.name) 
            if multiple==True:
                
                export_channels(timg,nwdrawable,wdir,True,name)
                pdb.gimp_message("Done, multiple files saved in directory %s" % wdir)
            
            else:
                    	                
    	        filename="separated-"+name+".psd"    	             
    	        fullpath=os.path.join(wdir,filename)
    	        if debug:print"Saving (channel mode)",fullpath            
    	        pdb.gimp_file_save(timg, timg.layers[0], fullpath, filename)
                pdb.gimp_message("Done, file saved in "+fullpath)      
                                
            
        
        else:    # elaborate as layers
            
            #delete old layer when finished
            timg.remove_layer(timg.layers[nrcol])
            #back to rgb for histogram to work
            ##pdb.gimp_image_convert_rgb(timg)
            if delback:background_deletion(timg)
            
            #make underlayer new position
            if underlayer>0: create_underlayer(timg,underlayer,shrink,enlargement,marks)
            
            #for each layer draw crosshair
            if marks==True:
                #color=pdb.gimp_palette_entry_get_color(palette,0)	
    		
                pdb.gimp_context_set_foreground(color)	
                if enlargement>1 :
                    pdb.gimp_context_set_brush("SmallCrossHair")
                else:
                    pdb.gimp_context_set_brush("CrossHair")    
                    
                
                xpos=50
                nrlayers=0
                for curentlayer in timg.layers:
                    #timg.active_layer=curentlayer
                    #draw crosshair
                    
                    nrlayers=nrlayers+1
                    pdb.gimp_paintbrush(curentlayer,0,2,[xpos,ypos,xpos,ypos],0,0)
                    pdb.gimp_paintbrush(curentlayer,0,2,[xpos+width-100,ypos,xpos+width-100,ypos],0,0)
                    
                
                 
                    #draw also some information
                pdb.gimp_context_set_foreground(pdb.gimp_palette_entry_get_color("Default",12)) 
                for n in range(nrlayers):
                    if debug:print"Info", n
                    info=timg.name+" "+timg.layers[n].name+" dot X"+str(enlargement)+" " +str(pdb.gimp_image_get_resolution(timg))+" ppi "+str(dithermode[dither]) 
                    
                    fl=pdb.gimp_text_fontname(timg,timg.layers[n],xpos-10,ypos+50,info,-1,False,20,0,"Sans") 
                                   
                    pdb.gimp_floating_sel_to_layer(fl)
                    
                        
                    for k in range(n):
                        pdb.gimp_image_lower_layer(timg,fl)
                                            
                    pdb.gimp_image_merge_down(timg,fl,0) #merge layers
                
                
                
             #back to rgb because of gimp_histogram routine and CorelDraw issues  
               
            
            #automatic background deletion
            #if delback:
            #    if debug:print"Deleting background"
            #    gimp.progress_init("Deleting background...")
            #    gimp.progress_update(0.5)
            #    biggerlayer=None
            #    oldpixelcount=0
            #    for curent_layer in timg.layers:
            #        timg.active_layer=curent_layer
	        #        
	        #        #set layer pixel counter for current layer (color) needed for background deletion
            #        (a,b,c,pixelcount,e,f)=pdb.gimp_histogram(timg.active_layer,0,0,255) 
            #        if pixelcount>oldpixelcount:
            #            oldpixelcount=pixelcount
            #            biggerlayer=curent_layer

            #    #delete found background
            #    timg.remove_layer(biggerlayer)
            #    gimp.progress_update(1)
        
            
            #underlayer option
            #if underlayer>0: create_underlayer(timg,underlayer,1,enlargement,marks)
            
            name,ext =os.path.splitext(timg.name)        
        
            #save multiple black&white files to be separately printed with printer or ripper
            if multiple==True: 
    	        #path=os.getcwd()   	        
    	        path=wdir
    	        export_layers(timg,nwdrawable,path,True,name)
    	        
                pdb.gimp_message("Done, multiple files saved in "+path)
    	        #TODO close current file without saving
    	        
    	        #TODO open every file
    	        
    	    #save one unic multicolor/multilayer file to be worked with CorelDraw for exemple     
            else:    
    	         	           	        
    	           	           
    	                
    	        filename="separated-"+name+".psd"
    	       
    	        #fullpath=os.path.join(os.getcwd(),filename)
    	        fullpath=os.path.join(wdir,filename)
    	        if debug:print"Saving (layer mode)",fullpath            
    	        pdb.gimp_file_save(timg, timg.layers[0], fullpath, filename)
                pdb.gimp_message("Done, file saved in "+fullpath)
	        
    else:
		if debug:print "Too many colors or wrong palette!"
		pdb.gimp_message("Too many colors or wrong palette!")
		#error : too many colors to do spot separation with
    
    
    pdb.gimp_image_undo_group_end(timg)
    
register(
        "Prepare-palette",
        "Prepare custom palette for spot colour separation.\nPalette name will be the same as image name.\n(Only manual mode is available for now)",
        "You have to make a custom palette where the first colours have to be black and white, then pick the background colour, then the other you need",
        "Robby Cerantola",
        "Robby Cerantola",
        "2010-2011",
        "<Image>/Spot/_Prepare palette...",
        "RGB*, GRAY*",
        [
                
                (PF_RADIO,"mode","Mode:",0,
                (("Manual",0),
                #("Mode 1",1),
                #("Mode 2",2),
                #("Mode 3",3)
                )),
                #(PF_BOOL,   "option", "Option 1", False),
                
                
                
                
        ],
        [],
        spot_palette)       



    
register(
        "Spot-separation",
        "Make a spot color separation using a custom palette",
        "You have to make a custom palette where the first colours have to be black and white, then pick the background colour, then the other you need",
        "Robby Cerantola",
        "Robby Cerantola",
        "2010-2011",
        "<Image>/Spot/_Spot-Separation...",
        "RGB*, GRAY*",
        [
                (PF_PALETTE, "palette", "P_alette name:", "Default"),
                (PF_RADIO,"dither","Type of dithering:",2,
                (("_None",0),
                ("Flo_yd-Steinberg",1),
                ("Floyd-Steinberg _reduced",2),
                ("Fi_xed",3))),
                (PF_BOOL,   "transparency", "Dit_her Transparency:", False),
                (PF_BOOL,   "marks", "_Marks & bars:", False),
                (PF_BOOL,   "multiple", "Multiple _files:", False),
                (PF_BOOL,   "delback","Delete bac_kground color:",False),
                
                (PF_RADIO,   "underlayer", "Automatic underlayer:",0,
                (("Non_e",0),
                ("Same _dimensions",1),
                ("_Bigger",2),
                ("_Smaller",3))),
                (PF_INT,   "enlargement","Pixel enlargement fac_tor",1),
                (PF_RADIO, "chla","Selection with ",0,
                (("_Layers",0),
                ("_Channels",1))),
                (PF_DIRNAME,"wdir","_Working directory",0)
                
                
                
        ],
        [],
        spot_separation)
        
register(
        "Palette_callback",
        "Do nothing after being selected a palette",
        "Return from external routine:do nothing",
        "Robby Cerantola",
        "Robby Cerantola",
        "2010-2011",
        "",
        "RGB*, GRAY*",
        [
                
                
                
                
        ],
        [],
        palette_callback)    


register(
        "Compute_pixel_enlagement",
        "Compute best pixel enlargement factor to be feed to spot-separation routine",
        "Compute best pixel enlargement factor upon image dimensions and resolution",
        "Robby Cerantola",
        "Robby Cerantola",
        "2010-2011",
        "<Image>/Spot/_Compute pixel enlargement...",
        "RGB*, GRAY*",
        [
                
                (PF_RADIO,"kind","Separation suitable for:",0,
                (("generic direct screen printing",0),
                ("screen printing with water based inks",1),
                ("screen printing with plastisol inks",2),
                ("transfers",3))),
                
                
                
                
                
        ],
        [],
        compute)       



           
        

main()


